/**
 * @fileoverview Audio processing pipeline with lunar influences
 * @author Hexbloop Audio Labs
 * 
 * Pipeline: Input ‚Üí Sox (mystical effects) ‚Üí FFmpeg (mastering) ‚Üí MP3 with embedded artwork
 */

const ffmpeg = require('fluent-ffmpeg');
const { spawn, execSync } = require('child_process');
const path = require('path');
const fs = require('fs');
const LunarProcessor = require('./lunar-processor');
const NameGenerator = require('./name-generator');
const ArtworkGenerator = require('./artwork-generator');
const MetadataEmbedder = require('./metadata-embedder');
const { getPreferencesManager } = require('./menu/preferences');

// Try to auto-detect ffmpeg path for macOS (homebrew installations)
try {
    const ffmpegPath = execSync('which ffmpeg', { encoding: 'utf8' }).trim();
    const ffprobePath = execSync('which ffprobe', { encoding: 'utf8' }).trim();
    
    if (ffmpegPath && ffprobePath) {
        ffmpeg.setFfmpegPath(ffmpegPath);
        ffmpeg.setFfprobePath(ffprobePath);
        console.log(`üé¨ FFmpeg configured: ${ffmpegPath}`);
    }
} catch (error) {
    console.log('‚ö†Ô∏è Could not auto-detect ffmpeg path, using system default');
}

class AudioProcessor {
    static async processFile(inputPath, outputPath) {
        console.log(`üéµ Processing: ${path.basename(inputPath)} -> ${path.basename(outputPath)}`);
        
        // Get user preferences for processing configuration
        const preferencesManager = getPreferencesManager();
        const processingConfig = preferencesManager.getProcessingConfig();
        const settings = preferencesManager.getSettings();
        
        // Extract the name from outputPath (already generated by main.js)
        // Remove .mp3 extension to get the mystical name
        let finalName = path.parse(path.basename(outputPath)).name;
        let customMetadata = null;
        
        // Handle custom metadata if provided
        if (processingConfig.stages.naming === 'custom' && processingConfig.metadata) {
            customMetadata = processingConfig.metadata;
            console.log(`üìù Using custom metadata`);
        }
        
        // Get lunar influences if enabled
        let influences = null;
        if (processingConfig.options.lunarInfluence && processingConfig.stages.compressing) {
            influences = LunarProcessor.getInfluencedParameters();
            console.log(`üåô ${influences.description}`);
        }
        
        // Temp files for processing stages
        const tempFile = path.join(path.dirname(outputPath), 'temp_audio.aif');
        const processedFile = path.join(path.dirname(outputPath), 'temp_processed.mp3');
        
        const artworkGenerator = new ArtworkGenerator();
        const metadataEmbedder = new MetadataEmbedder();
        
        try {
            let currentFile = inputPath;
            let artworkResult = null;
            
            // Step 1: Sox processing (conditional)
            if (processingConfig.stages.compressing && influences) {
                console.log('üéõÔ∏è Applying mystical compression...');
                await this.processSox(currentFile, tempFile, influences);
                currentFile = tempFile;
            } else if (processingConfig.stages.compressing) {
                console.log('üéõÔ∏è Applying standard compression (lunar influence disabled)...');
                // Use default influences for non-lunar processing
                const defaultInfluences = {
                    overdrive: 4.0,
                    bass: 2.0,
                    treble: 1.0,
                    echo: { delay: 0.3, decay: 0.05 },
                    compand: { attack: 0.2, ratio: 5 }
                };
                await this.processSox(currentFile, tempFile, defaultInfluences);
                currentFile = tempFile;
            } else {
                console.log('‚è≠Ô∏è Skipping compression stage');
            }
            
            // Step 2: FFmpeg mastering (conditional)
            if (processingConfig.stages.mastering) {
                console.log('üéöÔ∏è Applying mystical mastering...');
                const masteringInput = currentFile;
                const masteringOutput = processingConfig.stages.compressing ? processedFile : tempFile;
                await this.processFFmpeg(masteringInput, masteringOutput, settings);
                currentFile = masteringOutput;
            } else {
                console.log('‚è≠Ô∏è Skipping mastering stage');
                // If no mastering but we have a processed file, copy it
                if (currentFile !== inputPath) {
                    // Convert to MP3 without mastering
                    await this.convertToMp3(currentFile, processedFile);
                    currentFile = processedFile;
                }
            }
            
            // Step 3: Generate artwork (conditional)
            if (processingConfig.stages.coverArt) {
                console.log('üé® Generating mystical artwork...');
                const artworkPath = path.join(path.dirname(outputPath), `${finalName.replace(/[^a-zA-Z0-9]/g, '_')}_artwork.svg`);
                artworkResult = await artworkGenerator.generateArtwork(finalName, artworkPath);
            } else {
                console.log('‚è≠Ô∏è Skipping artwork generation');
            }
            
            // Step 4: Embed metadata (always happens, but content varies)
            console.log('üìã Embedding metadata...');
            const metadataForEmbedding = customMetadata ? {
                title: customMetadata.title || path.parse(path.basename(inputPath)).name,
                artist: customMetadata.artist,
                album: customMetadata.album,
                year: customMetadata.year,
                genre: customMetadata.genre
            } : {
                title: path.parse(path.basename(inputPath)).name,
                artist: finalName,
                album: 'Mystical Transmutations',
                year: new Date().getFullYear(),
                genre: 'Mystical Audio'
            };
            
            // If no processing was done, copy the original file and convert to MP3
            if (currentFile === inputPath) {
                await this.convertToMp3(inputPath, processedFile);
                currentFile = processedFile;
            }
            
            await metadataEmbedder.embedMetadata(
                currentFile, 
                outputPath, 
                metadataForEmbedding,
                artworkResult?.pngPath
            );
            
            // Clean up temp files
            if (fs.existsSync(tempFile)) {
                fs.unlinkSync(tempFile);
            }
            if (fs.existsSync(processedFile)) {
                fs.unlinkSync(processedFile);
            }
            
            // Clean up artwork files if they exist
            try {
                if (artworkResult && artworkResult.svgPath && fs.existsSync(artworkResult.svgPath)) {
                    fs.unlinkSync(artworkResult.svgPath);
                    console.log('üßπ Cleaned up SVG artwork file');
                }
                if (artworkResult && artworkResult.pngPath && fs.existsSync(artworkResult.pngPath)) {
                    fs.unlinkSync(artworkResult.pngPath);
                    console.log('üßπ Cleaned up PNG artwork file');
                }
            } catch (cleanupError) {
                console.log('‚ö†Ô∏è  Could not clean up artwork files:', cleanupError.message);
            }
            
            console.log(`‚úÖ Successfully processed: ${path.basename(outputPath)}`);
            return { 
                success: true, 
                finalName, 
                artwork: artworkResult,
                processingConfig,
                metadata: metadataForEmbedding
            };
            
        } catch (error) {
            // Clean up temp files on error
            if (fs.existsSync(tempFile)) {
                fs.unlinkSync(tempFile);
            }
            if (fs.existsSync(processedFile)) {
                fs.unlinkSync(processedFile);
            }
            throw error;
        }
    }
    
    static async processSox(inputPath, outputPath, influences) {
        return new Promise((resolve, reject) => {
            // Ensure influences object exists with defaults
            if (!influences) {
                influences = {
                    overdrive: 4.0,
                    bass: 2.0,
                    treble: 1.0,
                    echo: { delay: 0.3, decay: 0.05 },
                    compand: { attack: 0.2, ratio: 5 }
                };
            }
            
            // Sox effects chain with lunar-influenced parameters
            const soxProcess = spawn('sox', [
                inputPath,
                outputPath,
                'gain', '-n', '-1.5',                    // Normalize
                'overdrive', influences.overdrive.toString(), '2.5',  // Distortion
                'bass', `+${influences.bass}`,            // Low freq boost
                'treble', influences.treble >= 0 ? `+${influences.treble}` : influences.treble.toString(),  // High freq adjust
                'echo', influences.echo.delay.toString(), influences.echo.decay.toString(), '6.5', '0.045',  // Echo effect
                'compand', `${influences.compand.attack},0.6`, '6:-70,-60,-20', '-2', '-90', '0.25',  // Compression
                'rate', '44100',                          // Sample rate
                'dither'                                  // Dithering
            ]);
            
            let stderr = '';
            
            soxProcess.stderr.on('data', (data) => {
                stderr += data.toString();
            });
            
            soxProcess.on('close', (code) => {
                if (code === 0) {
                    console.log('‚ú® Sox processing complete');
                    resolve();
                } else {
                    console.log('‚ö†Ô∏è Sox not available, using FFmpeg for all processing...');
                    this.processWithFFmpegOnly(inputPath, outputPath, influences).then(resolve).catch(reject);
                }
            });
            
            soxProcess.on('error', (error) => {
                console.log('‚ö†Ô∏è Sox not found, using FFmpeg fallback...');
                this.processWithFFmpegOnly(inputPath, outputPath, influences).then(resolve).catch(reject);
            });
        });
    }
    
    static async convertToMp3(inputPath, outputPath) {
        return new Promise((resolve, reject) => {
            // Simple conversion to MP3 with high quality
            ffmpeg(inputPath)
                .format('mp3')
                .audioCodec('libmp3lame')
                .audioBitrate('320k')
                .audioFrequency(44100)
                .audioChannels(2)
                .on('start', (commandLine) => {
                    console.log('üéµ Converting to MP3: ' + commandLine);
                })
                .on('end', () => {
                    console.log('‚ú® MP3 conversion complete');
                    resolve();
                })
                .on('error', (err) => {
                    console.error('‚ùå MP3 conversion failed:', err.message);
                    reject(err);
                })
                .save(outputPath);
        });
    }
    
    static async processWithFFmpegOnly(inputPath, outputPath, influences) {
        return new Promise((resolve, reject) => {
            // FFmpeg fallback that approximates Sox effects
            const soxLikeFilters = [
                'volume=-1.5dB',
                `bass=g=${influences.bass}`,
                `treble=g=${influences.treble}`,
                `aecho=${influences.echo.delay}:${influences.echo.decay}:6.5:0.045`,
                `acompressor=threshold=-20dB:ratio=${influences.compand.ratio || 6}:attack=${influences.compand.attack * 1000}:release=250:makeup=2`
            ].join(',');
            
            ffmpeg(inputPath)
                .audioFilters(soxLikeFilters)
                .audioFrequency(44100)
                .audioChannels(2)
                .format('aiff')
                .on('start', (commandLine) => {
                    console.log('üéõÔ∏è FFmpeg sox-like processing: ' + commandLine);
                })
                .on('end', () => {
                    console.log('‚ú® FFmpeg sox-like processing complete');
                    resolve();
                })
                .on('error', (err) => {
                    console.error('‚ùå FFmpeg sox-like processing failed:', err.message);
                    reject(err);
                })
                .save(outputPath);
        });
    }
    
    static async processFFmpeg(inputPath, outputPath, settings = {}) {
        return new Promise((resolve, reject) => {
            // Extract format from output path or use settings
            const outputExt = path.extname(outputPath).slice(1).toLowerCase();
            const format = settings?.output?.format || outputExt || 'mp3';
            const quality = settings?.output?.quality || 'high';
            const sampleRate = settings?.output?.sampleRate || 44100;
            
            // Mastering chain: EQ ‚Üí Compression ‚Üí Limiting
            const filterComplex = [
                'equalizer=f=100:t=q:w=1:g=0.3',      // Low bass boost
                'equalizer=f=800:t=q:w=1.2:g=0.5',    // Low-mid presence
                'equalizer=f=1600:t=q:w=1:g=0.4',     // Mid clarity
                'equalizer=f=5000:t=q:w=1:g=0.3',     // High-mid sparkle
                'acompressor=threshold=-12dB:ratio=2:attack=100:release=1000:makeup=1.5',  // Gentle compression
                'alimiter=limit=0.97'                  // Brick wall limiter
            ].join(',');
            
            let command = ffmpeg(inputPath)
                .complexFilter(filterComplex)
                .audioChannels(2);
            
            // Set sample rate if not preserving original
            if (sampleRate > 0) {
                command = command.audioFrequency(sampleRate);
            }
            
            // Configure output format
            switch (format) {
                case 'mp3':
                    const mp3Bitrate = settings?.output?.mp3Bitrate || 320;
                    command = command
                        .format('mp3')
                        .audioCodec('libmp3lame')
                        .audioBitrate(`${mp3Bitrate}k`);
                    break;
                    
                case 'wav':
                    command = command
                        .format('wav')
                        .audioCodec('pcm_s16le'); // 16-bit PCM
                    break;
                    
                case 'flac':
                    const flacCompression = quality === 'maximum' ? 8 : quality === 'high' ? 5 : 2;
                    command = command
                        .format('flac')
                        .audioCodec('flac')
                        .outputOptions(`-compression_level ${flacCompression}`);
                    break;
                    
                case 'aac':
                case 'm4a':
                    const aacBitrate = quality === 'maximum' ? 320 : quality === 'high' ? 256 : quality === 'medium' ? 192 : 128;
                    command = command
                        .format('mp4')
                        .audioCodec('aac')
                        .audioBitrate(`${aacBitrate}k`);
                    break;
                    
                case 'ogg':
                    const oggQuality = quality === 'maximum' ? 10 : quality === 'high' ? 8 : quality === 'medium' ? 5 : 3;
                    command = command
                        .format('ogg')
                        .audioCodec('libvorbis')
                        .outputOptions(`-q:a ${oggQuality}`);
                    break;
                    
                case 'original':
                    // Keep original format, just apply effects
                    const originalExt = path.extname(inputPath).slice(1).toLowerCase();
                    command = command.format(originalExt);
                    break;
                    
                default:
                    // Default to MP3
                    command = command
                        .format('mp3')
                        .audioCodec('libmp3lame')
                        .audioBitrate('320k');
            }
            
            command
                .on('start', (commandLine) => {
                    console.log(`üéõÔ∏è FFmpeg mastering to ${format.toUpperCase()}: ${commandLine}`);
                })
                .on('progress', (progress) => {
                    if (progress.percent) {
                        process.stdout.write(`\rüéµ Processing: ${Math.round(progress.percent)}%`);
                    }
                })
                .on('end', () => {
                    console.log(`\n‚úÖ FFmpeg mastering complete (${format.toUpperCase()})`);
                    resolve();
                })
                .on('error', (err) => {
                    console.error('\n‚ùå FFmpeg mastering failed:', err.message);
                    reject(err);
                })
                .save(outputPath);
        });
    }
    
    /**
     * Simple MP3 conversion without mastering effects
     */
    static async convertToMp3(inputPath, outputPath) {
        return new Promise((resolve, reject) => {
            ffmpeg(inputPath)
                .audioFrequency(44100)
                .audioChannels(2)
                .format('mp3')
                .audioCodec('libmp3lame')
                .audioBitrate('320k')
                .on('start', (commandLine) => {
                    console.log('üéµ Converting to MP3: ' + commandLine);
                })
                .on('end', () => {
                    console.log('‚úÖ MP3 conversion complete');
                    resolve();
                })
                .on('error', (err) => {
                    console.error('‚ùå MP3 conversion failed:', err.message);
                    reject(err);
                })
                .save(outputPath);
        });
    }
}

module.exports = AudioProcessor;